/**
 * DO NOT EDIT THIS FILE MANUALLY.
 * This file has been generated automatically from its AsyncAPI spec file.
 * See : https://gitlab.com/3dverse/platform/libs/js/asyncapi-server-generator
 */

import { UUID } from "../sources/types";
import { EditorMessageHandler } from "./EditorMessageHandler";
import { ConnectConfirmation, EditorEntity, EntityUpdatedEvent } from "./messages/editor";

/**
 * Holds the connection to the Livelink Broadcast & Persistence server.
 */
export class EditorConnection {
    /**
     * Socket connected to the Livelink Broadcast & Persistence server.
     */
    #socket: WebSocket | null = null;

    /**
     * Controller responsible of handling the responses to queries.
     */
    #handler: EditorMessageHandler;

    /**
     * Constructs a connection linked to the specified message handler.
     */
    constructor({ handler }: { handler: EditorMessageHandler }) {
        this.#handler = handler;
    }

    /**
     * Opens a connection to the Livelink server.
     */
    async connect({ livelink_url }: { livelink_url: string }): Promise<void> {
        return new Promise((resolve, reject) => {
            this.#socket = new WebSocket(livelink_url);
            this.#socket.binaryType = "arraybuffer";

            this.#socket.onopen = (event: Event) => {
                this.#onSocketOpened(event);
                resolve();
            };

            this.#socket.onclose = this.#onSocketClosed;

            this.#socket.onerror = (event: Event) => {
                this.#onSocketError(event);
                reject();
            };

            this.#socket.onmessage = this.#onMessageReceived;
        });
    }

    /**
     *
     */
    send({ data }: { data: ArrayBufferLike | string }): void {
        this.#socket!.send(data);
    }

    /**
     *
     */
    disconnect() {
        this.#socket?.close();
    }

    /**
     *
     */
    #onSocketOpened = (_event: Event): void => {
        console.debug("Connected to the 3dverse Livelink broker");
    };

    /**
     *
     */
    #onSocketClosed = (_close_event: CloseEvent): void => {
        console.debug("Disconnected from the 3dverse Livelink broker");
    };

    /**
     *
     */
    #onSocketError = (_event: Event): void => {};

    /**
     *
     * @param message
     */
    #onMessageReceived = (message: MessageEvent<string>): void => {
        const payload = JSON.parse(message.data) as {
            type: string;
            emitter?: { clientUUID: UUID };
            data: {};
        };
        const handler = this.#handler!;

        if (!payload.emitter || handler.client_id !== payload.emitter.clientUUID) {
            console.log(`RECEIVED [${payload.type}]`, payload.emitter, payload.data);
        }

        switch (payload.type) {
            case "connect-confirmation":
                handler.onConnectConfirmation({
                    connect_confirmation: payload.data as ConnectConfirmation,
                });
                break;

            case "retrieve-children":
                handler.onRetrieveChildren(payload.data);
                break;

            case "find-entities-with-components":
                handler.onFindEntitiesWithComponents(payload.data);
                break;

            case "resolve-ancestors":
                handler.onResolveAncestors(payload.data as Array<EditorEntity>);
                break;

            case "find-entities-by-names":
                handler.onFindEntitiesByNames(payload.data);
                break;

            case "get-entities-by-euid":
                handler.onFindEntitiesByEUID(payload.data as Array<EditorEntity>);
                break;

            case "filter-entities":
                handler.onFilterEntities(payload.data);
                break;

            case "export-entity-to-scene":
                handler.onExportEntityToScene(payload.data);
                break;

            case "next-undo-redo":
                handler.onNextUndoRedo(payload.data);
                break;

            case "client-color":
                handler.onClientColor(payload.data);
                break;

            case "scene-stats-update":
                handler.onSceneStatsUpdate(payload.data);
                break;

            case "error":
                handler.onServerError(payload.data);
                break;

            // ACTIONS?
            case "entities-created":
                handler.on_entities_created(payload.data as Array<EditorEntity>);
                break;

            case "entities-deleted":
                handler.on_entities_deleted(payload.data as Array<UUID>);
                break;

            // Events
            case "update-components":
                handler.on_update_components(
                    payload.emitter?.clientUUID ?? null,
                    payload.data as Record<UUID, EntityUpdatedEvent>,
                );
                break;

            default:
                handler.onUnhandledMessage(payload.type, payload.data);
                break;
        }
    };
}
