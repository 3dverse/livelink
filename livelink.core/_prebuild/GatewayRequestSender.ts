/**
 * DO NOT EDIT THIS FILE MANUALLY.
 * This file has been generated automatically from its AsyncAPI spec file.
 * See : https://gitlab.com/3dverse/platform/libs/js/asyncapi-server-generator
 */

import { GatewayConnection } from "./GatewayConnection";
import {
  FTL_CLIENT_ROP_HEADER_SIZE,
  FTL_HEADER_SIZE,
  LITTLE_ENDIAN,
} from "./constants";
import {
  ChannelId,
  ClientConfig,
  ClientRemoteOperation,
  HighlightMode,
  RTID,
  SessionAuth,
  UUID,
  Vec2ui16,
  ViewportConfig,
  ViewportControlOperation,
  serialize_RTID,
  serialize_UUID,
  serialize_Vec2,
  serialize_Vec2ui16,
} from "./types";

/**
 *
 * This follows the LiveLink protocol specifications for the gateway messages.
 */
export class GatewayRequestSender {
  /**
   *
   */
  protected readonly _cluster_gateway_connection = new GatewayConnection();

  /**
   *
   */
  private _client_id: UUID | null = null;

  /**
   *
   */
  authenticateClient({ session_auth }: { session_auth: SessionAuth }): void {
    const payload = JSON.stringify({
      // Translate to legacy names
      sessionKey: session_auth.session_key,
      clientApp: session_auth.client_app,
      os: session_auth.os,
    });
    const buffer = new ArrayBuffer(2);
    new DataView(buffer).setUint16(0, payload.length, LITTLE_ENDIAN);
    this._cluster_gateway_connection.send({ data: buffer });
    this._cluster_gateway_connection.send({ data: payload });
  }

  /**
   *
   */
  pulseHeartbeat() {
    const buffer = new ArrayBuffer(FTL_HEADER_SIZE);
    this._writeMultiplexerHeader({
      buffer,
      channelId: ChannelId.heartbeat,
      size: 0,
    });
    this._cluster_gateway_connection.send({ data: buffer });
  }

  /**
   *
   */
  configureClient({ client_config }: { client_config: ClientConfig }) {
    const payload = JSON.stringify({
      // Translate to legacy names
      renderingAreaSize: client_config.rendering_area_size,
      encoderConfig: client_config.encoder_config,
      inputConfig: {
        hasKeyboard: client_config.supported_devices.keyboard,
        hasMouse: client_config.supported_devices.mouse,
        hasHololens: client_config.supported_devices.hololens,
        hasGamepad: client_config.supported_devices.gamepad,
        hasTouchscreen: client_config.supported_devices.touchscreen,
      },
    });
    const buffer = new ArrayBuffer(FTL_HEADER_SIZE);
    this._writeMultiplexerHeader({
      buffer,
      channelId: ChannelId.registration,
      size: payload.length,
    });
    this._cluster_gateway_connection.send({ data: buffer });
    this._cluster_gateway_connection.send({ data: payload });
  }

  /**
   *
   */
  setViewports({ viewports }: { viewports: Array<ViewportConfig> }) {
    const SIZE_OF_VIEWPORT_CONFIG = 20;
    const payloadSize = 2 + viewports.length * SIZE_OF_VIEWPORT_CONFIG;
    const buffer = new ArrayBuffer(FTL_HEADER_SIZE + payloadSize);
    this._writeMultiplexerHeader({
      buffer,
      channelId: ChannelId.viewer_control,
      size: payloadSize,
    });

    const writer = new DataView(buffer, FTL_HEADER_SIZE);
    let offset = 0;
    writer.setUint8(offset, ViewportControlOperation.set_viewports);
    offset += 1;
    writer.setUint8(offset, viewports.length);
    offset += 1;

    for (const viewport of viewports) {
      writer.setFloat32(offset, viewport.left, LITTLE_ENDIAN);
      offset += 4;
      writer.setFloat32(offset, viewport.top, LITTLE_ENDIAN);
      offset += 4;
      writer.setFloat32(offset, viewport.width, LITTLE_ENDIAN);
      offset += 4;
      writer.setFloat32(offset, viewport.height, LITTLE_ENDIAN);
      offset += 4;
      writer.setUint32(offset, viewport.camera_rtid, LITTLE_ENDIAN);
      offset += 4;
    }

    this._cluster_gateway_connection.send({ data: buffer });
  }

  /**
   *
   */
  resume() {
    const payloadSize = 1;
    const buffer = new ArrayBuffer(FTL_HEADER_SIZE + payloadSize);
    this._writeMultiplexerHeader({
      buffer,
      channelId: ChannelId.viewer_control,
      size: payloadSize,
    });

    const writer = new DataView(buffer, FTL_HEADER_SIZE);
    let offset = 0;
    writer.setUint8(offset, ViewportControlOperation.resume);
    offset += 1;

    this._cluster_gateway_connection.send({ data: buffer });
  }

  /**
   *
   */
  suspend() {
    const payloadSize = 1;
    const buffer = new ArrayBuffer(FTL_HEADER_SIZE + payloadSize);
    this._writeMultiplexerHeader({
      buffer,
      channelId: ChannelId.viewer_control,
      size: payloadSize,
    });

    const writer = new DataView(buffer, FTL_HEADER_SIZE);
    let offset = 0;
    writer.setUint8(offset, ViewportControlOperation.suspend);
    offset += 1;

    this._cluster_gateway_connection.send({ data: buffer });
  }

  /**
   *
   */
  resize({ size }: { size: Vec2ui16 }) {
    const payloadSize = 1 + 4;
    const buffer = new ArrayBuffer(FTL_HEADER_SIZE + payloadSize);
    this._writeMultiplexerHeader({
      buffer,
      channelId: ChannelId.viewer_control,
      size: payloadSize,
    });

    const writer = new DataView(buffer, FTL_HEADER_SIZE);
    let offset = 0;
    writer.setUint8(offset, ViewportControlOperation.resize);
    offset += 1;
    offset += serialize_Vec2ui16({ dataView: writer, offset, v: size });

    this._cluster_gateway_connection.send({ data: buffer });
  }

  /**
   *
   */
  castScreenSpaceRay({
    camera_rtid,
    x,
    y,
    mode,
  }: {
    camera_rtid: RTID;
    x: number;
    y: number;
    mode: HighlightMode;
  }) {
    const ropDataSize = 4 + 4 + 4 + 1;
    const payloadSize = FTL_CLIENT_ROP_HEADER_SIZE + ropDataSize;
    const buffer = new ArrayBuffer(FTL_HEADER_SIZE + payloadSize);

    this._writeMultiplexerHeader({
      buffer,
      channelId: ChannelId.client_remote_operations,
      size: payloadSize,
    });

    this._writeClientRemoteOerationMultiplexerHeader({
      buffer,
      offset: FTL_HEADER_SIZE,
      client_id: "",
      request_id: 0,
      rop_data_size: ropDataSize,
      rop_id: ClientRemoteOperation.cast_screen_space_ray,
    });

    let offset = 0;

    const writer = new DataView(buffer, FTL_HEADER_SIZE);
    offset += serialize_RTID({ dataView: writer, offset, rtid: camera_rtid });
    offset += serialize_Vec2({ dataView: writer, offset, v: [x, y] });
    writer.setUint8(offset, mode);

    this._cluster_gateway_connection.send({ data: buffer });
  }

  /**
   *
   */
  private _writeMultiplexerHeader({
    buffer,
    channelId,
    size,
  }: {
    buffer: ArrayBuffer;
    channelId: ChannelId;
    size: number;
  }) {
    const writer = new DataView(buffer);
    writer.setUint8(0, channelId);
    writer.setUint8(1, 0xff & (size >> 0));
    writer.setUint8(2, 0xff & (size >> 8));
    writer.setUint8(3, 0xff & (size >> 16));
  }

  /**
   *
   */
  private _writeClientRemoteOerationMultiplexerHeader({
    buffer,
    offset,
    client_id,
    request_id,
    rop_data_size,
    rop_id,
  }: {
    buffer: ArrayBuffer;
    offset: number;
    client_id: UUID;
    request_id: number;
    rop_data_size: number;
    rop_id: ClientRemoteOperation;
  }) {
    const writer = new DataView(buffer);

    offset += serialize_UUID({ dataView: writer, offset, uuid: client_id });

    writer.setUint32(offset, request_id, LITTLE_ENDIAN);
    offset += 4;

    writer.setUint32(offset, rop_data_size, LITTLE_ENDIAN);
    offset += 4;

    writer.setUint8(offset, rop_id);
    offset += 1;
  }
}
