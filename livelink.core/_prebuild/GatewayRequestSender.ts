/**
 * DO NOT EDIT THIS FILE MANUALLY.
 * This file has been generated automatically from its AsyncAPI spec file.
 * See : https://gitlab.com/3dverse/platform/libs/js/asyncapi-server-generator
 */

import { GatewayConnection } from "./GatewayConnection";
import { FTL_HEADER_SIZE, LITTLE_ENDIAN } from "./constants";
import {
  ChannelId,
  ClientConfig,
  HighlightMode,
  RTID,
  SessionAuth,
  Vec2i,
  ViewportConfig,
  ViewportControlOperation,
} from "./types";

export class GatewayRequestSender {
  /**
   *
   */
  protected readonly _cluster_gateway_connection = new GatewayConnection();

  /**
   *
   */
  authenticateClient({ session_auth }: { session_auth: SessionAuth }): void {
    const payload = JSON.stringify({
      sessionKey: session_auth.session_key,
      clientApp: session_auth.client_app,
      os: session_auth.os,
    });
    const buffer = new ArrayBuffer(2);
    new DataView(buffer).setUint16(0, payload.length, LITTLE_ENDIAN);
    this._cluster_gateway_connection.send({ data: buffer });
    this._cluster_gateway_connection.send({ data: payload });
  }

  /**
   *
   */
  pulseHeartbeat() {
    const buffer = new ArrayBuffer(FTL_HEADER_SIZE);
    this._writeMultiplexerHeader({
      buffer,
      channelId: ChannelId.heartbeat,
      size: 0,
    });
    this._cluster_gateway_connection.send({ data: buffer });
  }

  /**
   *
   */
  configureClient({ client_config }: { client_config: ClientConfig }) {
    const payload = JSON.stringify({
      renderingAreaSize: client_config.rendering_area_size,
      encoderConfig: client_config.encoder_config,
      inputConfig: {
        hasKeyboard: client_config.supported_devices.keyboard,
        hasMouse: client_config.supported_devices.mouse,
        hasHololens: client_config.supported_devices.hololens,
        hasGamepad: client_config.supported_devices.gamepad,
        hasTouchscreen: client_config.supported_devices.touchscreen,
      },
    });
    const buffer = new ArrayBuffer(FTL_HEADER_SIZE);
    this._writeMultiplexerHeader({
      buffer,
      channelId: ChannelId.registration,
      size: payload.length,
    });
    this._cluster_gateway_connection.send({ data: buffer });
    this._cluster_gateway_connection.send({ data: payload });
  }

  /**
   *
   */
  setViewports({ viewports }: { viewports: Array<ViewportConfig> }) {
    const SIZE_OF_VIEWPORT_CONFIG = 20;
    const payloadSize = 2 + viewports.length * SIZE_OF_VIEWPORT_CONFIG;
    const buffer = new ArrayBuffer(FTL_HEADER_SIZE + payloadSize);
    this._writeMultiplexerHeader({
      buffer,
      channelId: ChannelId.viewer_control,
      size: payloadSize,
    });

    const writer = new DataView(buffer, FTL_HEADER_SIZE);
    let offset = 0;
    writer.setUint8(offset, ViewportControlOperation.set_viewports);
    offset += 1;
    writer.setUint8(offset, viewports.length);
    offset += 1;

    for (const viewport of viewports) {
      writer.setFloat32(offset, viewport.left, LITTLE_ENDIAN);
      offset += 4;
      writer.setFloat32(offset, viewport.top, LITTLE_ENDIAN);
      offset += 4;
      writer.setFloat32(offset, viewport.width, LITTLE_ENDIAN);
      offset += 4;
      writer.setFloat32(offset, viewport.height, LITTLE_ENDIAN);
      offset += 4;
      writer.setUint32(offset, viewport.camera_rtid, LITTLE_ENDIAN);
      offset += 4;
    }

    this._cluster_gateway_connection.send({ data: buffer });
  }

  /**
   *
   */
  resume() {
    const payloadSize = 1;
    const buffer = new ArrayBuffer(FTL_HEADER_SIZE + payloadSize);
    this._writeMultiplexerHeader({
      buffer,
      channelId: ChannelId.viewer_control,
      size: payloadSize,
    });

    const writer = new DataView(buffer, FTL_HEADER_SIZE);
    let offset = 0;
    writer.setUint8(offset, ViewportControlOperation.resume);
    offset += 1;

    this._cluster_gateway_connection.send({ data: buffer });
  }

  /**
   *
   */
  suspend() {
    const payloadSize = 1;
    const buffer = new ArrayBuffer(FTL_HEADER_SIZE + payloadSize);
    this._writeMultiplexerHeader({
      buffer,
      channelId: ChannelId.viewer_control,
      size: payloadSize,
    });

    const writer = new DataView(buffer, FTL_HEADER_SIZE);
    let offset = 0;
    writer.setUint8(offset, ViewportControlOperation.suspend);
    offset += 1;

    this._cluster_gateway_connection.send({ data: buffer });
  }

  /**
   *
   */
  resize({ size }: { size: Vec2i }) {
    const payloadSize = 5;
    const buffer = new ArrayBuffer(FTL_HEADER_SIZE + payloadSize);
    this._writeMultiplexerHeader({
      buffer,
      channelId: ChannelId.viewer_control,
      size: payloadSize,
    });

    const writer = new DataView(buffer, FTL_HEADER_SIZE);
    let offset = 0;
    writer.setUint8(offset, ViewportControlOperation.resize);
    offset += 1;
    writer.setUint16(offset, size[0], LITTLE_ENDIAN);
    offset += 2;
    writer.setUint16(offset, size[1], LITTLE_ENDIAN);
    offset += 2;

    this._cluster_gateway_connection.send({ data: buffer });
  }

  /**
   *
   */
  castScreenSpaceRay({
    camera_rtid,
    x,
    y,
    mode,
  }: {
    camera_rtid: RTID;
    x: number;
    y: number;
    mode: HighlightMode;
  }) {
    const payloadSize = 8 + 4 + 4 + 1;
    const buffer = new ArrayBuffer(FTL_HEADER_SIZE + payloadSize);
    this._writeMultiplexerHeader({
      buffer,
      channelId: ChannelId.client_remote_operations,
      size: payloadSize,
    });

    // Write CLIENT ROP HEADER

    const writer = new DataView(buffer, FTL_HEADER_SIZE);
    writer.setBigInt64(FTL_HEADER_SIZE, camera_rtid, LITTLE_ENDIAN);
    writer.setFloat32(FTL_HEADER_SIZE + 8, x, LITTLE_ENDIAN);
    writer.setFloat32(FTL_HEADER_SIZE + 12, y, LITTLE_ENDIAN);
    writer.setUint8(FTL_HEADER_SIZE + 16, mode);

    this._cluster_gateway_connection.send({ data: buffer });
  }

  /**
   *
   */
  private _writeMultiplexerHeader({
    buffer,
    channelId,
    size,
  }: {
    buffer: ArrayBuffer;
    channelId: ChannelId;
    size: number;
  }) {
    const writer = new DataView(buffer);
    writer.setUint8(0, channelId);
    writer.setUint8(1, 0xff & (size >> 0));
    writer.setUint8(2, 0xff & (size >> 8));
    writer.setUint8(3, 0xff & (size >> 16));
  }
}
