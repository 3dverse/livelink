/**
 * DO NOT EDIT THIS FILE MANUALLY.
 * This file has been generated automatically from its AsyncAPI spec file.
 * See : https://gitlab.com/3dverse/platform/libs/js/asyncapi-server-generator
 */

import {
    FTL_CLIENT_ROP_HEADER_SIZE,
    FTL_EDITOR_ROP_HEADER_SIZE,
    FTL_HEADER_SIZE,
    FTL_VIEWER_CONTROL_ROP_HEADER_SIZE,
    LITTLE_ENDIAN,
} from "../sources/types/constants";

import {
    AssignClientToScriptMessage,
    AuthenticationResponse,
    ClientConfig,
    ClientConfigResponse,
    FireEventMessage,
    HighlightEntitiesMessage,
    InputState,
    RemoveComponentsCommand,
    ResizeResponse,
    SCREEN_SPACE_QUERY_BYTE_SIZE,
    ScreenSpaceRayQuery,
    ScreenSpaceRayResult,
    SessionAuth,
    UpdateAnimationSequenceStateMessage,
    UpdateEntitiesFromJsonMessage,
    VIEWPORT_CONFIG_BYTE_SIZE,
    ViewportConfig,
    comppute_UpdateAnimationSequenceStateMessage_size,
    compute_FireEventMessage_size,
    compute_HighlightEntitiesMessage_size,
    compute_InputState_size,
    compute_RemoveComponentsCommand_size,
    compute_UpdateEntitiesFromJsonMessage_size,
    deserialize_AuthenticationResponse,
    deserialize_ClientConfigResponse,
    deserialize_FrameData,
    deserialize_ResizeResponse,
    deserialize_ScreenSpaceRayResult,
    deserialize_ScriptEvent,
    serialize_FireEventMessage,
    serialize_HighlightEntitiesMessage,
    serialize_InputState,
    serialize_RemoveComponentsCommand,
    serialize_ScreenSpaceRayQuery,
    serialize_UpdateAnimationSequenceStateMessage,
    serialize_UpdateEntitiesFromJsonMessage,
    serialize_ViewportConfig,
    serialize_AssignClientToScriptMessage,
    ASSIGN_CLIENT_TO_SCRIPT_MESSAGE_BYTE_SIZE,
} from "./messages/gateway";

import {
    ChannelId,
    ClientRemoteOperation,
    EditorRemoteOperation,
    ViewerControlOperation,
} from "./messages/gateway/enums";

import { GatewayConnection } from "./GatewayConnection";

import { RequestHandler } from "../sources/RequestHandler";
import { UUID, Vec2ui16, serialize_UUID, serialize_Vec2ui16 } from "../sources/types";

/**
 * Meta data added to request resolvers to keep track of the rop and request id.
 */
type ResolverMetaData = {
    rop_id: ClientRemoteOperation | EditorRemoteOperation;
    request_id: number;
};

/**
 * Message handlers interface.
 * This follows the Livelink protocol specifications for the gateway messages.
 */
export class GatewayMessageHandler extends EventTarget {
    /**
     * The actual connection to the gateway.
     */
    readonly #connection = new GatewayConnection({ handler: this });

    /**
     * Handles messages that expect a response (requests).
     */
    readonly #request_handler = new RequestHandler<ChannelId, ResolverMetaData>();

    /**
     * A unique id generator for requests so that we can match which response corresponds to which
     * request.
     */
    #request_id_generator = 1;

    /**
     * The id of the current client, generated once we are authenticated.
     */
    #client_id: UUID | null = null;

    /**
     * Opens the connection to the specified gateway.
     */
    protected _connect({ gateway_url }: { gateway_url: string }): Promise<void> {
        return this.#connection.connect({ gateway_url });
    }

    /**
     * Closes any ongoing connection with the gateway.
     */
    protected _disconnect(): void {
        this.#connection.disconnect();
    }

    /***************************************************************************
     * AUTHENTICATION
     **************************************************************************/
    /**
     * Request
     */
    authenticateClient({ session_auth }: { session_auth: SessionAuth }): Promise<AuthenticationResponse> {
        const payload = JSON.stringify({
            // Translate to legacy names
            sessionKey: session_auth.session_key,
            clientApp: session_auth.client_app,
            os: session_auth.os,
        });

        const buffer = new ArrayBuffer(2);
        new DataView(buffer).setUint16(0, payload.length, LITTLE_ENDIAN);

        this.#connection.send({ data: buffer });
        this.#connection.send({ data: payload });

        return this.#request_handler.makeRequestResolver<AuthenticationResponse>({
            channel_id: ChannelId.authentication,
        });
    }

    /**
     * Reply
     */
    _on_authenticateClient_response({ data_view }: { data_view: DataView }): void {
        const authRes = deserialize_AuthenticationResponse({ data_view, offset: 0 });
        this.#client_id = authRes.client_id;
        this.#request_handler.getNextRequestResolver({ channel_id: ChannelId.authentication }).resolve(authRes);
    }

    /***************************************************************************
     * HEARTBEAT
     **************************************************************************/
    /**
     * Request
     */
    pulseHeartbeat(): Promise<void> {
        const buffer = new ArrayBuffer(FTL_HEADER_SIZE);
        this.#writeMultiplexerHeader({ buffer, channelId: ChannelId.heartbeat, size: 0 });
        this.#connection.send({ data: buffer });

        return this.#request_handler.makeRequestResolver<void>({ channel_id: ChannelId.heartbeat });
    }

    /**
     * Reply
     */
    _on_pulseHeartbeat_response(): void {
        this.#request_handler.getNextRequestResolver({ channel_id: ChannelId.heartbeat }).resolve();
    }

    /***************************************************************************
     * REGISTRATION
     **************************************************************************/
    /**
     * Request
     */
    configureClient({ client_config }: { client_config: ClientConfig }): Promise<ClientConfigResponse> {
        const payload = JSON.stringify({
            // Translate to legacy names
            renderingAreaSize: client_config.remote_canvas_size,
            encoderConfig: client_config.encoder_config,
            inputConfig: {
                hasKeyboard: client_config.supported_devices.keyboard,
                hasMouse: client_config.supported_devices.mouse,
                hasHololens: client_config.supported_devices.hololens,
                hasGamepad: client_config.supported_devices.gamepad,
                hasTouchscreen: client_config.supported_devices.touchscreen,
            },
        });

        const buffer = new ArrayBuffer(FTL_HEADER_SIZE);
        this.#writeMultiplexerHeader({ buffer, channelId: ChannelId.registration, size: payload.length });

        this.#connection.send({ data: buffer });
        this.#connection.send({ data: payload });

        return this.#request_handler.makeRequestResolver<ClientConfigResponse>({ channel_id: ChannelId.registration });
    }

    /**
     * Reply
     */
    _on_configureClient_response({ data_view }: { data_view: DataView }): void {
        this.#request_handler
            .getNextRequestResolver({ channel_id: ChannelId.registration })
            .resolve(deserialize_ClientConfigResponse({ data_view, offset: 0 }));
    }

    /***************************************************************************
     * VIEWER CONTROL
     **************************************************************************/
    /**
     * Send
     */
    setViewports({ viewports }: { viewports: Array<ViewportConfig> }): void {
        const payloadSize = 1 + viewports.length * VIEWPORT_CONFIG_BYTE_SIZE;
        const buffer = new ArrayBuffer(FTL_HEADER_SIZE + FTL_VIEWER_CONTROL_ROP_HEADER_SIZE + payloadSize);
        this.#writeMultiplexerHeader({ buffer, channelId: ChannelId.viewer_control, size: payloadSize });

        const writer = new DataView(buffer, FTL_HEADER_SIZE);
        let offset = 0;
        writer.setUint8(offset, ViewerControlOperation.set_viewports);
        offset += 1;

        writer.setUint8(offset, viewports.length);
        offset += 1;

        for (const viewportConfig of viewports) {
            offset += serialize_ViewportConfig({ data_view: writer, offset, viewportConfig });
        }

        this.#connection.send({ data: buffer });
    }

    /**
     * Send
     */
    resume(): void {
        const payloadSize = FTL_VIEWER_CONTROL_ROP_HEADER_SIZE;
        const buffer = new ArrayBuffer(FTL_HEADER_SIZE + payloadSize);
        this.#writeMultiplexerHeader({ buffer, channelId: ChannelId.viewer_control, size: payloadSize });

        const writer = new DataView(buffer, FTL_HEADER_SIZE);
        let offset = 0;
        writer.setUint8(offset, ViewerControlOperation.resume);
        offset += 1;

        this.#connection.send({ data: buffer });
    }

    /**
     * Send
     */
    suspend(): void {
        const payloadSize = FTL_VIEWER_CONTROL_ROP_HEADER_SIZE;
        const buffer = new ArrayBuffer(FTL_HEADER_SIZE + payloadSize);
        this.#writeMultiplexerHeader({ buffer, channelId: ChannelId.viewer_control, size: payloadSize });

        const writer = new DataView(buffer, FTL_HEADER_SIZE);
        let offset = 0;
        writer.setUint8(offset, ViewerControlOperation.suspend);
        offset += 1;

        this.#connection.send({ data: buffer });
    }

    /**
     * Request
     */
    resize({ size }: { size: Vec2ui16 }): Promise<ResizeResponse> {
        const payloadSize = FTL_VIEWER_CONTROL_ROP_HEADER_SIZE + 4;
        const buffer = new ArrayBuffer(FTL_HEADER_SIZE + payloadSize);
        this.#writeMultiplexerHeader({ buffer, channelId: ChannelId.viewer_control, size: payloadSize });

        const writer = new DataView(buffer, FTL_HEADER_SIZE);
        let offset = 0;
        writer.setUint8(offset, ViewerControlOperation.resize);
        offset += 1;

        offset += serialize_Vec2ui16({ data_view: writer, offset, v: size });
        offset += 4;

        this.#connection.send({ data: buffer });

        return this.#request_handler.makeRequestResolver<ResizeResponse>({ channel_id: ChannelId.viewer_control });
    }

    /**
     * Reply
     */
    _on_resize_response({ data_view }: { data_view: DataView }): void {
        this.#request_handler
            .getNextRequestResolver({ channel_id: ChannelId.viewer_control })
            .resolve(deserialize_ResizeResponse({ data_view, offset: 0 }));
    }

    /***************************************************************************
     * INPUTS
     **************************************************************************/
    /**
     * Send
     */
    sendInputState({ input_state }: { input_state: InputState }): void {
        const payloadSize = compute_InputState_size({ input_state });
        const buffer = new ArrayBuffer(FTL_HEADER_SIZE + payloadSize);

        this.#writeMultiplexerHeader({ buffer, channelId: ChannelId.inputs, size: payloadSize });

        serialize_InputState({ data_view: new DataView(buffer, FTL_HEADER_SIZE), input_state });

        this.#connection.send({ data: buffer });
    }

    /***************************************************************************
     * VIDEO STREAM
     **************************************************************************/
    /**
     * Receive
     */
    _onFrameReceived({ data_view }: { data_view: DataView }): void {
        const frame_data = deserialize_FrameData({ data_view });
        this.dispatchEvent(new CustomEvent("on-frame-received", { detail: frame_data }));
    }

    /***************************************************************************
     * SCRIPT EVENTS
     **************************************************************************/
    /**
     * Receive
     */
    _onScriptEventReceived({ data_view }: { data_view: DataView }): void {
        const script_event = deserialize_ScriptEvent({ data_view });
        this.dispatchEvent(new CustomEvent("on-script-event-received", { detail: script_event }));
    }

    /***************************************************************************
     * CLIENT REMOTE OPERATIONS
     **************************************************************************/
    /**
     * Request
     */
    castScreenSpaceRay({
        screenSpaceRayQuery,
    }: {
        screenSpaceRayQuery: ScreenSpaceRayQuery;
    }): Promise<ScreenSpaceRayResult> {
        const ropDataSize = SCREEN_SPACE_QUERY_BYTE_SIZE;
        const payloadSize = FTL_CLIENT_ROP_HEADER_SIZE + ropDataSize;
        const buffer = new ArrayBuffer(FTL_HEADER_SIZE + payloadSize);

        this.#writeMultiplexerHeader({ buffer, channelId: ChannelId.client_remote_operations, size: payloadSize });

        const rop_id = ClientRemoteOperation.cast_screen_space_ray;
        const request_id = this.#writeRemoteOperationMultiplexerHeader({
            buffer,
            offset: FTL_HEADER_SIZE,
            rop_data_size: ropDataSize,
            rop_id,
        });

        serialize_ScreenSpaceRayQuery({
            data_view: new DataView(buffer, FTL_HEADER_SIZE + FTL_CLIENT_ROP_HEADER_SIZE),
            screenSpaceRayQuery,
        });

        this.#connection.send({ data: buffer });

        return this.#request_handler.makeRequestResolver<ScreenSpaceRayResult>({
            channel_id: ChannelId.client_remote_operations,
            meta_data: { rop_id, request_id },
        });
    }

    /**
     * Send
     */
    highlightEntities({ highlightEntitiesMessage }: { highlightEntitiesMessage: HighlightEntitiesMessage }): void {
        const ropDataSize = compute_HighlightEntitiesMessage_size({ highlightEntitiesMessage });
        const payloadSize = FTL_CLIENT_ROP_HEADER_SIZE + ropDataSize;
        const buffer = new ArrayBuffer(FTL_HEADER_SIZE + payloadSize);

        this.#writeMultiplexerHeader({ buffer, channelId: ChannelId.client_remote_operations, size: payloadSize });

        this.#writeRemoteOperationMultiplexerHeader({
            buffer,
            offset: FTL_HEADER_SIZE,
            rop_data_size: ropDataSize,
            rop_id: ClientRemoteOperation.select_entities,
        });

        serialize_HighlightEntitiesMessage({
            data_view: new DataView(buffer, FTL_HEADER_SIZE + FTL_CLIENT_ROP_HEADER_SIZE),
            highlightEntitiesMessage,
        });

        this.#connection.send({ data: buffer });
    }

    /**
     * Reply
     */
    _on_clientRemoteOperation_response({
        client_id,
        request_id,
        size,
        data_view,
    }: {
        client_id: UUID;
        request_id: number;
        size: number;
        data_view: DataView;
    }): void {
        if (client_id !== this.#client_id) {
            console.warn(
                `Received a response from client ${client_id}, whereas we are client ${this.#client_id}. Something's off.`,
            );
        }

        const resolver = this.#request_handler.getNextRequestResolver({
            channel_id: ChannelId.client_remote_operations,
        });

        if (!resolver.meta_data) {
            throw new Error("Someting went wrong with the client remote operations resolver. Meta data is missing.");
        }

        if (resolver.meta_data.request_id !== request_id) {
            throw new Error(`Expected request id ${resolver.meta_data.request_id}, received ${request_id}`);
        }

        if (resolver.meta_data.rop_id === undefined) {
            throw new Error("Resolver has and undefined ROP id");
        }

        switch (resolver.meta_data.rop_id) {
            case ClientRemoteOperation.cast_screen_space_ray:
                resolver.resolve(deserialize_ScreenSpaceRayResult({ data_view, offset: 0 }));
                break;

            default:
                throw new Error(
                    `Received a response for a client remote operation on an unhandled ROP channel ${
                        ClientRemoteOperation[resolver.meta_data.rop_id!]
                    }`,
                );
        }
    }

    /***************************************************************************
     * EDITOR REMOTE OPERATIONS
     **************************************************************************/
    /**
     * Send
     */
    fireEvent({ fireEventMessage }: { fireEventMessage: FireEventMessage }): void {
        const ropDataSize = compute_FireEventMessage_size(fireEventMessage);
        const payloadSize = FTL_EDITOR_ROP_HEADER_SIZE + ropDataSize;
        const buffer = new ArrayBuffer(FTL_HEADER_SIZE + payloadSize);

        this.#writeMultiplexerHeader({ buffer, channelId: ChannelId.editor_remote_operations, size: payloadSize });

        this.#writeRemoteOperationMultiplexerHeader({
            buffer,
            offset: FTL_HEADER_SIZE,
            rop_data_size: ropDataSize,
            rop_id: EditorRemoteOperation.fire_event,
        });

        serialize_FireEventMessage({
            data_view: new DataView(buffer, FTL_HEADER_SIZE + FTL_EDITOR_ROP_HEADER_SIZE),
            fireEventMessage,
        });

        this.#connection.send({ data: buffer });
    }

    /**
     * Send
     */
    updateAnimationSequenceState({
        updateAnimationSequenceStateMessage,
    }: {
        updateAnimationSequenceStateMessage: UpdateAnimationSequenceStateMessage;
    }): void {
        const ropDataSize = comppute_UpdateAnimationSequenceStateMessage_size({ updateAnimationSequenceStateMessage });
        const payloadSize = FTL_EDITOR_ROP_HEADER_SIZE + ropDataSize;
        const buffer = new ArrayBuffer(FTL_HEADER_SIZE + payloadSize);

        this.#writeMultiplexerHeader({ buffer, channelId: ChannelId.editor_remote_operations, size: payloadSize });

        this.#writeRemoteOperationMultiplexerHeader({
            buffer,
            offset: FTL_HEADER_SIZE,
            rop_data_size: ropDataSize,
            rop_id: EditorRemoteOperation.update_animation_sequence_state,
        });

        serialize_UpdateAnimationSequenceStateMessage({
            data_view: new DataView(buffer, FTL_HEADER_SIZE + FTL_EDITOR_ROP_HEADER_SIZE),
            updateAnimationSequenceStateMessage,
        });

        this.#connection.send({ data: buffer });
    }

    /**
     * Send
     */
    assignClientToScript({
        assignClientToScriptMessage,
    }: {
        assignClientToScriptMessage: AssignClientToScriptMessage;
    }): void {
        const ropDataSize = ASSIGN_CLIENT_TO_SCRIPT_MESSAGE_BYTE_SIZE;
        const payloadSize = FTL_EDITOR_ROP_HEADER_SIZE + ropDataSize;
        const buffer = new ArrayBuffer(FTL_HEADER_SIZE + payloadSize);

        this.#writeMultiplexerHeader({ buffer, channelId: ChannelId.editor_remote_operations, size: payloadSize });

        this.#writeRemoteOperationMultiplexerHeader({
            buffer,
            offset: FTL_HEADER_SIZE,
            rop_data_size: ropDataSize,
            rop_id: EditorRemoteOperation.assign_client_uuid_to_script,
        });

        serialize_AssignClientToScriptMessage({
            data_view: new DataView(buffer, FTL_HEADER_SIZE + FTL_EDITOR_ROP_HEADER_SIZE),
            assignClientToScriptMessage,
        });

        this.#connection.send({ data: buffer });
    }

    /**
     * Send
     */
    updateEntities({
        updateEntitiesFromJsonMessage,
    }: {
        updateEntitiesFromJsonMessage: UpdateEntitiesFromJsonMessage;
    }): void {
        const ropDataSize = compute_UpdateEntitiesFromJsonMessage_size(updateEntitiesFromJsonMessage);
        const payloadSize = FTL_EDITOR_ROP_HEADER_SIZE + ropDataSize;
        const buffer = new ArrayBuffer(FTL_HEADER_SIZE + payloadSize);

        this.#writeMultiplexerHeader({ buffer, channelId: ChannelId.editor_remote_operations, size: payloadSize });

        this.#writeRemoteOperationMultiplexerHeader({
            buffer,
            offset: FTL_HEADER_SIZE,
            rop_data_size: ropDataSize,
            rop_id: EditorRemoteOperation.update_entities_from_json,
        });

        serialize_UpdateEntitiesFromJsonMessage({
            data_view: new DataView(buffer, FTL_HEADER_SIZE + FTL_EDITOR_ROP_HEADER_SIZE),
            updateEntitiesFromJsonMessage,
        });

        this.#connection.send({ data: buffer });
    }

    /**
     * Send
     */
    removeComponents({ removeComponentsCommand }: { removeComponentsCommand: RemoveComponentsCommand }): void {
        const ropDataSize = compute_RemoveComponentsCommand_size(removeComponentsCommand);
        const payloadSize = FTL_EDITOR_ROP_HEADER_SIZE + ropDataSize;
        const buffer = new ArrayBuffer(FTL_HEADER_SIZE + payloadSize);

        this.#writeMultiplexerHeader({ buffer, channelId: ChannelId.editor_remote_operations, size: payloadSize });

        this.#writeRemoteOperationMultiplexerHeader({
            buffer,
            offset: FTL_HEADER_SIZE,
            rop_data_size: ropDataSize,
            rop_id: EditorRemoteOperation.remove_components,
        });

        serialize_RemoveComponentsCommand({
            data_view: new DataView(buffer, FTL_HEADER_SIZE + FTL_EDITOR_ROP_HEADER_SIZE),
            removeComponentsCommand,
        });

        this.#connection.send({ data: buffer });
    }

    /**
     *
     */
    #writeMultiplexerHeader({ buffer, channelId, size }: { buffer: ArrayBuffer; channelId: ChannelId; size: number }) {
        const writer = new DataView(buffer);
        writer.setUint8(0, channelId);
        writer.setUint8(1, 0xff & (size >> 0));
        writer.setUint8(2, 0xff & (size >> 8));
        writer.setUint8(3, 0xff & (size >> 16));
    }

    /**
     *
     */
    #writeRemoteOperationMultiplexerHeader({
        buffer,
        offset,
        rop_data_size,
        rop_id,
    }: {
        buffer: ArrayBuffer;
        offset: number;
        rop_data_size: number;
        rop_id: ClientRemoteOperation | EditorRemoteOperation;
    }): number {
        const writer = new DataView(buffer);

        offset += serialize_UUID({ data_view: writer, offset, uuid: this.#client_id! });

        const request_id = this.#request_id_generator++;

        writer.setUint32(offset, request_id, LITTLE_ENDIAN);
        offset += 4;

        writer.setUint32(offset, rop_data_size, LITTLE_ENDIAN);
        offset += 4;

        writer.setUint8(offset, rop_id);
        offset += 1;

        return request_id;
    }
}
