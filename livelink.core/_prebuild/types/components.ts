/**
 * DO NOT EDIT THIS FILE MANUALLY.
 * This file has been generated automatically from ftl-schemas
 */

import type { RTID, UUID, Quat, Vec3, Vec2, Int32, UInt32, Float, Int8} from "../../sources/types";
import type * as Assets from "./assets";

/**
 *
 */
export type ComponentType = keyof typeof ComponentHash;

/**
 *
 */
export type AssetRef<T> = UUID;

/**
 *
 */
export type EntityRef = {
    originalEUID: UUID;
    linkage: Array<UUID>;
};

/**
 *
 */
export type Euid = {
    value: UUID;
    rtid: RTID;
};

/**
* Animation controller with reference to an animation graph and an animation set. Enables skeletal animation on its skinned mesh descendents whose skeleton is compatible with the animations in the animation set.
*/
export type AnimationController = Partial<{
    /**
     * UUID of the referenced animation graph.
     */
    animationGraphRef: AssetRef<Assets.AnimationGraph>;
    /**
     * UUID of the referenced animation set.
     */
    animationSetRef: AssetRef<Assets.AnimationSet>;
    /**
     * Input values as described in the referenced animation graph in their original JSON format.
     */
    dataJSON: Record<string, unknown>;
    /**
     * Reference to the entity with the bone component that corresponds the root bone of the skeleton.
     */
    rootBoneEntityRef: EntityRef;
    /**
     * Whether or not root motion is enabled.
     */
    rootMotionEnabled: boolean;
}>;

/**
* Links entity to bone in skeleton.
*/
export type Bone = Partial<{
    /**
     * Index of bone in skeleton.
     */
    boneIndex: UInt32;
}>;

/**
* Box geometry.
*/
export type BoxGeometry = Partial<{
    /**
     * Width, height and depth of the box.
     */
    dimension: Vec3;
    /**
     * Geometry offset.
     */
    offset: Vec3;
}>;

/**
* Virtual camera.
*/
export type Camera = Partial<{
    /**
     * UUID of the referenced render graph this camera should use.
     */
    renderGraphRef: AssetRef<Assets.RenderGraph>;
    /**
     * Index of the render target to blit.
     */
    renderTargetIndex: Int32;
    /**
     * Input values as described in the referenced render graph in their original JSON format.
     */
    dataJSON: Record<string, unknown>;
}>;

/**
* Capsule geometry.
*/
export type CapsuleGeometry = Partial<{
    /**
     * Radius of the spheres at each end of the capsule.
     */
    radius: Float;
    /**
     * Height of the cylindrical part of the capsule.
     */
    height: Float;
    /**
     * Alignment axis. 0 for X, 1 for Y, 2 for Z.
     */
    axis: Int32;
    /**
     * Geometry offset.
     */
    offset: Vec3;
}>;

/**
* Character controller used for movement constrained by collisions without having to deal with a rigid body. A character controller is kinematic, and so is not affected by forces. It uses its own tweaked collision algorithm to give a good feeling while controlling the character.
*/
export type CharacterController = Partial<{
    /**
     * Step offset. If the height of a step is greater than stepOffset, the controller cannot climb automatically and gets stuck.
     */
    stepOffset: Float;
    /**
     * Slope limit in degrees. A slope steeper than the slopeLimit will not be walkable by the controller.
     */
    slopeLimit: Float;
    /**
     * The character's collision skin width.
     */
    skinWidth: Float;
    /**
     * Displacement vector for current frame.
     */
    displacement: Vec3;
}>;

/**
* Reference to a collision geometry.
*/
export type CollisionGeometryRef = Partial<{
    /**
     * UUID of the referenced collision geometry.
     */
    collisionGeometryRef: AssetRef<Assets.CollisionGeometry>;
}>;

/**
* A physics constraint that can be configured along 6 degrees of freedom. In its default state it behaves as a fixed constraint - that is, it rigidly fixes the constraint frames of its two entities. However, individual degrees of freedom may be unlocked to permit any combination of rotation around the x-, y- and z- axes, and translation along these axes.
*/
export type Constraint = Partial<{
    /**
     * Motion along the X axis
     */
    motionAlongX: Int32;
    /**
     * Motion along the Y axis
     */
    motionAlongY: Int32;
    /**
     * Motion along the Z axis
     */
    motionAlongZ: Int32;
    /**
     * Motion around the X axis
     */
    motionAroundX: Int32;
    /**
     * Motion around the Y axis
     */
    motionAroundY: Int32;
    /**
     * Motion around the Z axis
     */
    motionAroundZ: Int32;
    /**
     * The lower distance of the limit.
     */
    motionLowerLimit: Vec3;
    /**
     * The upper distance of the limit.
     */
    motionUpperLimit: Vec3;
    /**
     * If greater than zero, the limit is soft, i.e. a spring pulls the joint back to the limit.
     */
    motionLimitSpringStiffness: Vec3;
    /**
     * If greater than zero, this is the damping of the limit spring.
     */
    motionLimitSpringDamping: Vec3;
    /**
     * The limit angle from the Y-axis and the Z-axis of the constraint frame. The cone limit is used if either or both swing axes are limited. The extents are symmetrical and measured in the frame of the parent. If only one swing degree of freedom is limited, the corresponding value from the cone limit defines the limit range.
     */
    swingLimitAngle: Vec2;
    /**
     * If greater than zero, the limit is soft, i.e. a spring pulls the joint back to the limit.
     */
    swingSpringStiffness: Float;
    /**
     * If greater than zero, this is the damping of the limit spring.
     */
    swingSpringDamping: Float;
    /**
     * The twist limit controls the range of motion around the twist axis. The limit angle range is (-360, 360).
     */
    twistLimitAngle: Vec2;
    /**
     * If greater than zero, the limit is soft, i.e. a spring pulls the joint back to the limit.
     */
    twistSpringStiffness: Float;
    /**
     * If greater than zero, this is the damping of the limit spring.
     */
    twistSpringDamping: Float;
    /**
     * If greater than zero, the limit is soft, i.e. a spring pulls the joint back to the limit.
     */
    linearDriveStiffness: Vec3;
    /**
     * If greater than zero, this is the damping of the limit spring.
     */
    linearDriveDamping: Vec3;
    /**
     * The maximum impulse or force that can be exerted by the drive. -1 for no limit.
     */
    linearDriveForceLimit: Vec3;
    /**
     * If greater than zero, the limit is soft, i.e. a spring pulls the joint back to the limit.
     */
    angularDriveStiffness: Vec3;
    /**
     * If greater than zero, this is the damping of the limit spring.
     */
    angularDriveDamping: Vec3;
    /**
     * The maximum impulse or force that can be exerted by the drive. -1 for no limit.
     */
    angularDriveForceLimit: Vec3;
    /**
     * The drive type
     */
    driveType: Int8;
    /**
     * The goal velocity for linear drive.
     */
    driveLinearVelocity: Vec3;
    /**
     * The goal velocity for angular drive.
     */
    driveAngularVelocity: Vec3;
}>;

/**
* Culling geometry. Add this component in addition to another geometry component (e.g. box geometry, sphere geometry, etc.) to enable culling geometry.
*/
export type CullingGeometry = Partial<{
    /**
     * Additive geometry will only display elements (vertices or voxels) inside the geometry. Subtractive will only display elements outside the geometry.
     */
    isAdditive: boolean;
}>;

/**
* Cylinder geometry.
*/
export type CylinderGeometry = Partial<{
    /**
     * Radius of the cylinder.
     */
    radius: Float;
    /**
     * Height of the cylinder.
     */
    height: Float;
    /**
     * Alignment axis. 0 for X, 1 for Y, 2 for Z.
     */
    axis: Int32;
    /**
     * Geometry offset.
     */
    offset: Vec3;
}>;

/**
* Name of the entity.
*/
export type DebugName = Partial<{
    /**
     * Entity name.
     */
    value: string;
}>;

/**
* Decal Projector.
*/
export type DecalProjector = Partial<{
    /**
     * Z-Index order of the decal projection. The higher index will render on top of the lower ones.
     */
    zIndex: Int32;
}>;

/**
* The environment of a scene. Used to give a scene a skybox.
*/
export type Environment = Partial<{
    /**
     * UUID of the skybox cubemap.
     */
    skyboxUUID: AssetRef<Assets.Cubemap>;
    /**
     * Reference to the radiance cubemap.
     */
    radianceUUID: AssetRef<Assets.Cubemap>;
    /**
     * Reference to the irradiance cubemap.
     */
    irradianceUUID: AssetRef<Assets.Cubemap>;
}>;

/**
* Base component of all the other joint components (revolute_joint, etc.). By itself it will lock the orientations and distances of the constrainer and constrainee.
*/
export type Joint = Partial<{
    /**
     * An entity that is a rigid body.
     */
    constrainee: EntityRef;
    /**
     * An entity that is a rigid or static body, or simply null.
     */
    constrainer: EntityRef;
    /**
     * The force that needs to be applied for this joint to break.
     */
    breakForce: Float;
    /**
     * The torque that needs to be applied for this joint to break.
     */
    breakTorque: Float;
    /**
     * Whether to enable collision between constrainer and constrainee.
     */
    enableCollision: boolean;
}>;

/**
* Lineage of the entity through linkers.
*/
export type Lineage = Partial<{
    /**
     * UUID of the parent of this entity (default is root).
     */
    parentUUID: UUID;
    /**
     * Ordinal number of this entity in respect of its siblings.
     */
    ordinal: Int32;
}>;

/**
* Local Axis Aligned Bounding Box of the entity.
*/
export type LocalAabb = Partial<{
    /**
     * Minimum point of the box.
     */
    min: Vec3;
    /**
     * Maximum point of the box.
     */
    max: Vec3;
}>;

/**
* Local transform of the entity.
*/
export type LocalTransform = Partial<{
    /**
     * x, y, z position of the entity.
     */
    position: Vec3;
    /**
     * Orientation of the entity expressed as a quaternion.
     */
    orientation: Quat;
    /**
     * x, y, z scale of the entity.
     */
    scale: Vec3;
    /**
     * Orientation of the entity expressed as euler angles.
     */
    eulerOrientation: Vec3;
    /**
     * Last global orientation of the entity expressed as euler angles submitted by a user. This value may not be valid, and should be checked.
     */
    globalEulerOrientation: Vec3;
}>;

/**
* References a shader and specifies input values if needed.
*/
export type Material = Partial<{
    /**
     * UUID of the referenced shader.
     */
    shaderRef: AssetRef<Assets.Shader>;
    /**
     * Whether the material is double sided or not.
     */
    isDoubleSided: boolean;
    /**
     * Input values as described in the referenced shader in their original JSON format.
     */
    dataJSON: Record<string, unknown>;
    /**
     * Specialization constants values as described in the referenced shader in their original JSON format.
     */
    constantsJSON: Record<string, unknown>;
}>;

/**
* Reference to a material.
*/
export type MaterialRef = Partial<{
    /**
     * UUID of the referenced material.
     */
    value: AssetRef<Assets.Material>;
    /**
     * Face culling mode. 0 to inherit from material, 1 for single sided, 2 for double sided.
     */
    faceCulling: Int32;
}>;

/**
* Reference to a mesh.
*/
export type MeshRef = Partial<{
    /**
     * UUID of the referenced mesh.
     */
    value: AssetRef<Assets.Mesh>;
    /**
     * Index of the submesh inside the mesh's submesh array.
     */
    submeshIndex: Int32;
}>;

/**
* A lens that applies an orthographic projection.
*/
export type OrthographicLens = Partial<{
    /**
     * Left plane.
     */
    left: Float;
    /**
     * Right plane.
     */
    right: Float;
    /**
     * Top plane.
     */
    top: Float;
    /**
     * Bottom plane.
     */
    bottom: Float;
    /**
     * Near plane.
     */
    zNear: Float;
    /**
     * Far plane.
     */
    zFar: Float;
}>;

/**
* Overrides a given entity in a sub scene.
*/
export type Overrider = Partial<{
    /**
     * Mark the overridden entity as deleted.
     */
    deleter: boolean;
    /**
     * Entity to override.
     */
    entityRef: EntityRef;
    /**
     * Hashes of the components to detach from the overridden entity.
     */
    componentsToDetach: Array<Int32>;
}>;

/**
* A lens that applies a perspective projection.
*/
export type PerspectiveLens = Partial<{
    /**
     * Aspect ratio of the viewport, usually equals width/height.
     */
    aspectRatio: Float;
    /**
     * Field of view angle in the y direction.
     */
    fovy: Float;
    /**
     * Distance from the viewer to the near clipping plane.
     */
    nearPlane: Float;
    /**
     * Distance from the viewer to the far clipping plane.
     */
    farPlane: Float;
}>;

/**
* Physics material which represents a set of physical surface properties.
*/
export type PhysicsMaterial = Partial<{
    /**
     * The friction coefficient applied between this surface and another surface if they are not moving lateral to each other. Usually a value from 0 to 1. A value of zero feels like ice, a value of 1 will make it very hard to get the object moving. Resulting static friction of a physics body colliding with another is determined by the average of both bodies' static friction coefficient.
     */
    staticFriction: Float;
    /**
     * The friction coefficient applied between this surface and another surface if they are moving relative to each other. Usually a value from 0 to 1. A value of zero feels like ice, a value of 1 will make it very hard to get the object moving. If set to greater than staticFriction, the effective value of staticFriction will be increased to match. Resulting dynamic friction of a physics body colliding with another is determined by the average of both bodies' dynamic friction coefficient.
     */
    dynamicFriction: Float;
    /**
     * Restitution coefficient, or bounciness of surface. A coefficient of 0 indicates as little bounce as possible, higher values up to 1.0 result in more bounce. Should be in the range [0,1]. Resulting bounciness of a physics body colliding with another is determined by the average of both bodies' restitution.
     */
    restitution: Float;
    /**
     * The velocity applied to the contact between this physics body and another body. Only applies if modifyContact is true.
     */
    contactVelocity: Vec3;
    /**
     * Whether to modify the contact when this physics body collides with another body.
     */
    modifyContact: boolean;
    /**
     * Whether to consider the geometry associated to this physics material as a trigger or not.
     */
    isTrigger: boolean;
}>;

/**
* Plane geometry.
*/
export type PlaneGeometry = Partial<{
    /**
     * Distance from the origin in the plane's normal direction.
     */
    distance: Float;
    /**
     * Normal of the plane.
     */
    normal: Vec3;
}>;

/**
* Reference to a point cloud.
*/
export type PointCloudRef = Partial<{
    /**
     * UUID of the referenced point cloud.
     */
    value: AssetRef<Assets.PointCloud>;
}>;

/**
* A light with color and intensity. A point light by default, add a spot light component to add a cutoff. Can be parameterized to simulate the atmosphere sun.
*/
export type PointLight = Partial<{
    /**
     * Light color.
     */
    color: Vec3;
    /**
     * Light intensity.
     */
    intensity: Float;
    /**
     * The range for the point light. If the range is 0, then physically correct point light attenuation function is used.
     */
    range: Float;
    /**
     * Make this light directional, position is ignored in this case.
     */
    isDirectional: boolean;
    /**
     * Make this light direction control the atmosphere sun direction. If more than one light is marked to be a sun results are undefined.
     */
    isSun: boolean;
}>;

/**
* Omni directional reflection probe parameters, used for local cubemap reflection generation.
*/
export type ReflectionProbe = Partial<{
    /**
     * x, y, z offset of the probe reflection origin.
     */
    offset: Vec3;
    /**
     * Distance to the near plane.
     */
    nearDist: Float;
    /**
     * Distance to the far plane.
     */
    farDist: Float;
    /**
     * Resolution of the reflection map.
     */
    quality: Int32;
}>;

/**
* Revolute joint which keeps the origins and x-axes of the frames together, and allows free rotation around this common axis.
*/
export type RevoluteJoint = Partial<{
    /**
     * The minimum angle the rotation can go (in degrees).
     */
    minRotation: Float;
    /**
     * The maximum angle the rotation can go (in degrees).
     */
    maxRotation: Float;
    /**
     * If greater than zero, the rotation limits (minRotation, maxRotation) are soft, i.e. a spring pulls the joint back to the limit.
     */
    stiffness: Float;
    /**
     * If stiffness is greater than zero, this is the damping of the limit spring.
     */
    damping: Float;
}>;

/**
* Rigid body parameters.
*/
export type RigidBody = Partial<{
    /**
     * Mass of the rigid body. A value of 0 is interpreted as infinite mass.
     */
    mass: Float;
    /**
     * Center of mass. Relative to the entity's transform.
     */
    centerOfMass: Vec3;
    /**
     * Linear damping coefficient. Used to slow down the rigid body's linear velocity. Zero represents no damping. Must be non-negative.
     */
    linearDamping: Float;
    /**
     * Angular damping coefficient. Used to slow down the rigid body's angular velocity, i.e. how much it rotates. Zero represents no damping. Must be non-negative.
     */
    angularDamping: Float;
    /**
     * 
     */
    force: Vec3;
    /**
     * 
     */
    torque: Vec3;
    /**
     * The type of collision detection to use for this rigid body.
     */
    collisionDetection: Int32;
    /**
     * Controls whether rigid body is affected by gravity.
     */
    useGravity: boolean;
    /**
     * Specifies if rigid body is kinematic. Kinematic rigid bodies are not affected by forces such as gravity.
     */
    isKinematic: boolean;
}>;

/**
* Reference to a scene.
*/
export type SceneRef = Partial<{
    /**
     * UUID of the referenced scene.
     */
    value: AssetRef<Assets.Scene>;
    /**
     * Maximum number of times a scene appears when it references itself.
     */
    maxRecursionCount: UInt32;
}>;

/**
* References a script and specifies input values if needed.
*/
export type ScriptElement = Partial<{
    /**
     * UUID of the referenced script.
     */
    scriptRef: AssetRef<Assets.Script>;
    /**
     * Input values as described in the referenced script in their original JSON format.
     */
    dataJSON: Record<string, unknown>;
}>;

/**
* References multiple scripts.
*/
export type ScriptMap = Partial<{
    /**
     * List of scripts.
     */
    elements: Record<UUID, ScriptElement>;
}>;

/**
* Enables a light to cast shadows.
*/
export type ShadowCaster = Partial<{
    /**
     * Bias to apply to avoid self shadowing artifacts.
     */
    bias: Float;
    /**
     * Distance to the near plane.
     */
    nearDist: Float;
    /**
     * Distance to the far plane.
     */
    farDist: Float;
    /**
     * Resolution of the shadow map.
     */
    quality: Int32;
    /**
     * Skews the ratio of cascade splits, value ranges from 0 to 1.
     */
    cascadeSplitLambda: Float;
    /**
     * Distance to the end of the furthest cascade.
     */
    cascadeMaxZ: Float;
    /**
     * For directional lights, accumulate all shadow cascades.
     */
    accumulateShadowCascades: boolean;
}>;

/**
* Reference to a skeleton.
*/
export type SkeletonRef = Partial<{
    /**
     * UUID of the referenced skeleton.
     */
    value: AssetRef<Assets.Skeleton>;
}>;

/**
* Reference to a sound.
*/
export type SoundRef = Partial<{
    /**
     * UUID of the referenced sound.
     */
    value: AssetRef<Assets.Sound>;
    /**
     * Volume from 0.0f to 1.0f.
     */
    volume: Float;
    /**
     * Pan. -1.0f is left, 1.0f is right.
     */
    pan: Float;
    /**
     * The speed at which the sound will play. 1.0f is normal.
     */
    playSpeed: Float;
    /**
     * Whether or not the sound loops.
     */
    looping: boolean;
}>;

/**
* Sphere geometry.
*/
export type SphereGeometry = Partial<{
    /**
     * Radius of the sphere.
     */
    radius: Float;
    /**
     * Geometry offset.
     */
    offset: Vec3;
}>;

/**
* Adds a cutoff to a point light to simulate a spot light.
*/
export type SpotLight = Partial<{
    /**
     * Cutoff angle.
     */
    cutoff: Float;
    /**
     * Reference to a IES 2d texture.
     */
    IESProfile: AssetRef<Assets.Texture>;
}>;

/**
* A lens that applies an off-center perspective projection.
*/
export type StereoscopicLens = Partial<{
    /**
     * Angle of the left side of the field of view (this value is negative).
     */
    angleLeft: Float;
    /**
     * Angle of the right side of the field of view.
     */
    angleRight: Float;
    /**
     * Angle of the top part of the field of view.
     */
    angleUp: Float;
    /**
     * Angle of the bottom part of the field of view (this value is negative).
     */
    angleDown: Float;
    /**
     * Specifies the distance from the viewer to the near clipping plane.
     */
    nearPlane: Float;
    /**
     * Specifies the distance from the viewer to the far clipping plane.
     */
    farPlane: Float;
    /**
     * Specifies the aspect ratio of the viewport, usually equals width/height.
     */
    aspectRatio: Float;
}>;

/**
* Tags used to filter entities.
*/
export type Tags = Partial<{
    /**
     * Tag list.
     */
    value: Array<string>;
}>;

/**
* Vehicle Controller parameters.
*/
export type VehicleController = Partial<{
    /**
     * The chassis.
     */
    chassis: EntityRef;
    /**
     * The front left wheel.
     */
    frontLeftWheel: EntityRef;
    /**
     * The front right wheel.
     */
    frontRightWheel: EntityRef;
    /**
     * The rear left wheel.
     */
    rearLeftWheel: EntityRef;
    /**
     * The rear right wheel.
     */
    rearRightWheel: EntityRef;
}>;

/**
* Filtering properties applied to the volume.
*/
export type VolumeFilter = Partial<{
    /**
     * Voxel intensity range displayed, not applicable if outside volume material range.
     */
    range: Vec2;
    /**
     * Apply gaussian filtering on voxels.
     */
    applyGaussianFiltering: boolean;
    /**
     * Are texel values from the voxel texture sampled unfiltered.
     */
    sampleUnfiltered: boolean;
    /**
     * Whether or not this volume is visible in the MPR view.
     */
    enableMPR: boolean;
    /**
     * Whether or not this volume is visible in the 3D view.
     */
    enable3D: boolean;
}>;

/**
* Reference to a material to use with a volume.
*/
export type VolumeMaterialRef = Partial<{
    /**
     * UUID of the referenced volume material.
     */
    value: AssetRef<Assets.VolumeMaterial>;
}>;

/**
* Reference to a volume made of voxels.
*/
export type VolumeRef = Partial<{
    /**
     * UUID of the referenced 3D texture.
     */
    texture3dRef: AssetRef<Assets.Texture3D>;
}>;

/**
 *
 */
export enum ComponentHash {
    animation_controller = 2978761622,
    bone = 1352454807,
    box_geometry = 3718707752,
    camera = 1515175333,
    capsule_geometry = 3996568839,
    character_controller = 304568171,
    collision_geometry_ref = 3193374355,
    constraint = 3735282166,
    culling_geometry = 611599156,
    cylinder_geometry = 2497701877,
    debug_name = 2737255849,
    decal_projector = 2842087135,
    environment = 227427331,
    joint = 2286235554,
    lineage = 2698448560,
    local_aabb = 4132624459,
    local_transform = 64958624,
    material = 4100970527,
    material_ref = 2816861126,
    mesh_ref = 1660697531,
    orthographic_lens = 3326403741,
    overrider = 2758112134,
    perspective_lens = 1113360699,
    physics_material = 1550394949,
    plane_geometry = 4075752378,
    point_cloud_ref = 457361603,
    point_light = 3624222817,
    reflection_probe = 3879689944,
    revolute_joint = 1364947094,
    rigid_body = 3452128059,
    scene_ref = 371342060,
    script_element = 3574396804,
    script_map = 3291722836,
    shadow_caster = 3403528636,
    skeleton_ref = 36879215,
    sound_ref = 369352309,
    sphere_geometry = 1159992935,
    spot_light = 1508811228,
    stereoscopic_lens = 698679321,
    tags = 163258925,
    vehicle_controller = 1287796174,
    volume_filter = 2625356468,
    volume_material_ref = 3229245461,
    volume_ref = 2808449574,
};
