/**
 * DO NOT EDIT THIS FILE MANUALLY.
 * This file has been generated automatically from its AsyncAPI spec file.
 * See : https://gitlab.com/3dverse/platform/libs/js/asyncapi-server-generator
 */

import {
  AuthenticationStatus,
  ChannelId,
  ClientRemoteOperation,
  UUID,
  Vec2i,
  Vec3,
  deserialize_FrameMetaData,
} from "./types";

import { GatewayMessageHandler } from "./GatewayMessageHandler";
import { FTL_HEADER_SIZE, LITTLE_ENDIAN } from "./constants";

/**
 * Holds the connection to the cluster gateway hosting the renderer
 * and the viewer handling the targeted session.
 */
export class GatewayConnection {
  /**
   * Socket connected to the cluster gateway.
   */
  private _socket: WebSocket | null = null;

  /**
   * Controller responsible of handling the responses to queries.
   */
  private _handler: GatewayMessageHandler | null = null;

  /**
   * Opens a connection to the gateway.
   *
   * @throws Socket errors
   */
  async connect({
    gateway_url,
    handler,
  }: {
    gateway_url: string;
    handler: GatewayMessageHandler;
  }): Promise<void> {
    this._handler = handler;

    return new Promise((resolve) => {
      this._socket = new WebSocket(gateway_url);
      this._socket.binaryType = "arraybuffer";

      this._socket.onopen = (event: Event) => {
        this._onSocketOpened(event);
        resolve();
      };

      this._socket.onclose = (close_event: CloseEvent) =>
        this._onSocketClosed(close_event);

      this._socket.onerror = () => {
        throw new Error("Gateway socket error");
      };

      // Temporary onmessage that handles only authentication response message.
      // When the socket is opened we send a message to authenticate the client,
      // then the renderer sends us back the confirmation (or an error).
      // This callback handles only this authentication response message.
      // As soon as the authentication is validated, we switch to the regular
      // multiplexed message handler callback.
      this._socket.onmessage = (message: MessageEvent<any>) =>
        this._onAuthenticated(message);
    });
  }

  /**
   *
   */
  send({ data }: { data: ArrayBufferLike | string }): void {
    this._socket?.send(data);
  }

  /**
   *
   */
  private _onSocketOpened(event: Event) {}

  /**
   *
   */
  private _onAuthenticated(message: MessageEvent<ArrayBuffer>) {
    this._authenticateClient_response({ dataView: new DataView(message.data) });

    console.log("Received authentication response");

    // Switch the onmessage callback to the regular multiplexed one.
    this._socket!.onmessage = (message: MessageEvent<ArrayBuffer>) =>
      this._onMessageReceived({ message });
  }

  /**
   *
   */
  private _onSocketClosed(close_event: CloseEvent) {
    if (close_event.wasClean === false) {
      console.error("Socket forcibly closed");
    } else {
      console.log("Gateway connection closed", close_event);
    }
  }

  /**
   *
   * @param message
   */
  private _onMessageReceived({
    message,
  }: {
    message: MessageEvent<ArrayBuffer>;
  }): void {
    // First byte is the channel id.
    // 3 following bytes is the message total size EXCLUDING the first 4 bytes.
    const channelId = new DataView(message.data).getUint8(0) as ChannelId;
    const dataView = new DataView(message.data, FTL_HEADER_SIZE);

    switch (channelId) {
      case ChannelId.registration:
        this._configureClient_response({ dataView });
        break;

      case ChannelId.heartbeat:
        this._pulseHeartbeat_response({ dataView });
        break;

      case ChannelId.viewer_control:
        this._onViewerResized({ dataView });
        break;

      case ChannelId.video_stream:
        this._onFrameReceived({ dataView });
        break;

      case ChannelId.client_remote_operations:
        this._clientRemoteOperation_response({ dataView });
    }
  }

  /**
   * Cluster gateway response
   */
  private _authenticateClient_response({ dataView }: { dataView: DataView }) {
    const status = dataView.getUint16(0, LITTLE_ENDIAN) as AuthenticationStatus;
    const client_id = deserialize_uuid(dataView, dataView.byteOffset + 2);

    this._handler!.on_authenticateClient_response({ status, client_id });
  }

  /**
   * Cluster gateway response
   */
  private _pulseHeartbeat_response({ dataView }: { dataView: DataView }) {
    this._handler!.on_pulseHeartbeat_response();
  }

  /**
   * Remote viewer response
   */
  private _configureClient_response({ dataView }: { dataView: DataView }) {
    this._handler!.on_configureClient_response({
      codec: dataView.getUint8(0),
    });
  }

  /**
   *
   */
  private _onViewerResized({ dataView }: { dataView: DataView }) {
    const size: Vec2i = [
      dataView.getUint16(0, LITTLE_ENDIAN),
      dataView.getUint16(2, LITTLE_ENDIAN),
    ];

    this._handler!.on_resize_response({ size });
  }

  /**
   * Remote viewer message.
   */
  private _onFrameReceived({ dataView }: { dataView: DataView }) {
    let offset = 0;

    const encoded_frame_size = dataView.getUint32(offset, LITTLE_ENDIAN);
    offset += 4;

    const meta_data_size = dataView.getUint32(offset, LITTLE_ENDIAN);
    offset += 4;

    const encoded_frame = new DataView(
      dataView.buffer,
      dataView.byteOffset + offset,
      encoded_frame_size
    );
    offset += encoded_frame_size;

    this._handler!.onFrameReceived({
      encoded_frame_size,
      meta_data_size,
      encoded_frame,
      meta_data: deserialize_FrameMetaData({ dataView, offset }),
    });
  }

  /**
   * Rendering server response.
   */
  private _clientRemoteOperation_response({
    dataView,
  }: {
    dataView: DataView;
  }) {
    const FTL_CLIENT_ROP_HEADER_SIZE = 24;
    const rop_id = dataView.getUint8(0);
    const ropDataView = new DataView(
      dataView.buffer,
      FTL_CLIENT_ROP_HEADER_SIZE
    );

    switch (rop_id) {
      case ClientRemoteOperation.cast_screen_space_ray:
        this._castScreenSpaceRay_response({ dataView: ropDataView });
        break;
    }
  }

  /**
   * Rendering server response.
   */
  private _castScreenSpaceRay_response({ dataView }: { dataView: DataView }) {
    const entity_rtid = dataView.getBigUint64(0, LITTLE_ENDIAN);
    const position: Vec3 = [
      dataView.getFloat32(8, LITTLE_ENDIAN),
      dataView.getFloat32(12, LITTLE_ENDIAN),
      dataView.getFloat32(16, LITTLE_ENDIAN),
    ];
    const normal: Vec3 = [
      dataView.getFloat32(20, LITTLE_ENDIAN),
      dataView.getFloat32(24, LITTLE_ENDIAN),
      dataView.getFloat32(28, LITTLE_ENDIAN),
    ];

    this._handler!.on_castScreenSpaceRay_response({
      entity_rtid,
      position,
      normal,
    });
  }
}

const byteToHex: string[] = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).slice(1));
}

function deserialize_uuid(v: DataView, offset = 0) {
  const arr = new Uint8Array(v.buffer, v.byteOffset + offset, 16);

  var data1 = v.getUint32(offset + 0, true);
  var data2 = v.getUint16(offset + 4, true);
  var data3 = v.getUint16(offset + 6, true);

  v.setUint32(offset + 0, data1, false);
  v.setUint16(offset + 4, data2, false);
  v.setUint16(offset + 6, data3, false);
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434

  return (
    byteToHex[arr[0]] +
    byteToHex[arr[1]] +
    byteToHex[arr[2]] +
    byteToHex[arr[3]] +
    "-" +
    byteToHex[arr[4]] +
    byteToHex[arr[5]] +
    "-" +
    byteToHex[arr[6]] +
    byteToHex[arr[7]] +
    "-" +
    byteToHex[arr[8]] +
    byteToHex[arr[9]] +
    "-" +
    byteToHex[arr[10]] +
    byteToHex[arr[11]] +
    byteToHex[arr[12]] +
    byteToHex[arr[13]] +
    byteToHex[arr[14]] +
    byteToHex[arr[15]]
  );
}
