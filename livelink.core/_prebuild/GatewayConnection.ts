/**
 * DO NOT EDIT THIS FILE MANUALLY.
 * This file has been generated automatically from its AsyncAPI spec file.
 * See : https://gitlab.com/3dverse/platform/libs/js/asyncapi-server-generator
 */

import {
  AuthenticationStatus,
  ChannelId,
  ClientRemoteOperation,
  deserialize_FrameMetaData,
  deserialize_Vec2ui16,
  deserialize_Vec3,
  deserialize_UUID,
} from "./types";

import { GatewayMessageHandler } from "./GatewayMessageHandler";
import { FTL_HEADER_SIZE, LITTLE_ENDIAN } from "./constants";

/**
 * Holds the connection to the cluster gateway hosting the renderer
 * and the viewer handling the session.
 *
 *                     ┌─────────┬──────────────┐
 *                     │         │              │
 *                     │         │ ┌──────────┐ │
 *                     │         │ │ Renderer │ │
 *                     │         │ └─────┬────┘ │
 *    ┌────────┐       │         │       │      │
 *    │ Client │◄──────► Gateway ◄───────┤      │
 *    └────────┘       │         │       │      │
 *                 ▲   │         │  ┌────┴───┐  │
 *                 |   │         │  │ Viewer │  │
 * GatewayConnection   │         │  └────────┘  │
 *                     │         │              │
 *                     └─────────┴──────────────┘
 *
 * Responsibilities of this class are threefold:
 *  - Open, maintain, and handle any error in the connection to the gateway
 *
 *  - Apply the authentication protocol when the first message is received.
 *    Note that initiating the authentication doesn't fall under this class's purview.
 *
 *  - Demultiplex and deserialize messages following the gateway LiveLink Protocol.
 *    This class is only responsible for deserializing the binary data according to
 *    the LiveLink protocol specifications; in no case is it supposed to apply any
 *    kind of logic beyond routing messages to the appropriate handler.
 */
export class GatewayConnection {
  /**
   * Socket connected to the cluster gateway.
   */
  private _socket: WebSocket | null = null;

  /**
   * Controller responsible of handling messages coming from the gateway.
   */
  private _handler: GatewayMessageHandler | null = null;

  /**
   * Opens a connection to the gateway.
   *
   * @throws {Error} Socket errors
   */
  async connect({
    gateway_url,
    handler,
  }: {
    gateway_url: string;
    handler: GatewayMessageHandler;
  }): Promise<void> {
    this._handler = handler;

    return new Promise((resolve) => {
      this._socket = new WebSocket(gateway_url);
      this._socket.binaryType = "arraybuffer";

      this._socket.onopen = (event: Event) => {
        this._onSocketOpened(event);
        resolve();
      };

      this._socket.onclose = (close_event: CloseEvent) =>
        this._onSocketClosed(close_event);

      this._socket.onerror = () => {
        throw new Error("Gateway socket error");
      };

      // Temporary onmessage that handles only authentication response message.
      // When the socket is opened we send a message to authenticate the client,
      // then the renderer sends us back the confirmation (or an error).
      // This callback handles only this authentication response message.
      // As soon as the authentication is validated, we switch to the regular
      // multiplexed message handler callback.
      this._socket.onmessage = (message: MessageEvent<any>) =>
        this._onAuthenticated(message);
    });
  }

  /**
   *
   */
  send({ data }: { data: ArrayBufferLike | string }): void {
    this._socket?.send(data);
  }

  /**
   *
   */
  disconnect() {
    this._socket?.close();
  }

  /**
   *
   */
  private _onSocketOpened(_event: Event) {
    console.debug(
      "Connected to the 3dverse rendering gateway:",
      this._socket?.url
    );
  }

  /**
   *
   */
  private _onSocketClosed(closeEvent: CloseEvent) {
    if (closeEvent.wasClean === false) {
      console.error("Gateway socket forcibly closed", closeEvent);
    } else {
      console.debug("Disconnected from the 3dverse rendering gateway");
    }
  }

  /**
   *
   */
  private _onAuthenticated(message: MessageEvent<ArrayBuffer>) {
    this._authenticateClient_response({ dataView: new DataView(message.data) });

    // Switch the onmessage callback to the regular multiplexed one.
    this._socket!.onmessage = (message: MessageEvent<ArrayBuffer>) =>
      this._onMessageReceived({ message });
  }

  /**
   *
   */
  private _onMessageReceived({
    message,
  }: {
    message: MessageEvent<ArrayBuffer>;
  }): void {
    // First byte is the channel id.
    // 3 following bytes is the message total size EXCLUDING the first 4 bytes.
    const channelId = new DataView(message.data).getUint8(0) as ChannelId;
    const dataView = new DataView(message.data, FTL_HEADER_SIZE);

    switch (channelId) {
      case ChannelId.registration:
        this._configureClient_response({ dataView });
        break;

      case ChannelId.heartbeat:
        this._pulseHeartbeat_response({ dataView });
        break;

      case ChannelId.viewer_control:
        this._resize_response({ dataView });
        break;

      case ChannelId.video_stream:
        this._onFrameReceived({ dataView });
        break;

      case ChannelId.client_remote_operations:
        this._clientRemoteOperation_response({ dataView });
        break;

      default:
        throw new Error(`Received message on unknown channel ${channelId}`);
    }
  }

  /**
   * Cluster gateway response to authentication query.
   * See {@link GatewayRequestSender#authenticateClient}.
   */
  private _authenticateClient_response({ dataView }: { dataView: DataView }) {
    let offset = 0;

    const status = dataView.getUint16(
      offset,
      LITTLE_ENDIAN
    ) as AuthenticationStatus;
    offset += 2;

    const client_id = deserialize_UUID({
      dataView,
      offset: offset,
    });

    this._handler!.on_authenticateClient_response({ status, client_id });
  }

  /**
   * Cluster gateway response to pulseHearbeat query.
   * See {@link GatewayRequestSender#pulseHeartBeat}.
   */
  private _pulseHeartbeat_response({}: { dataView: DataView }) {
    this._handler!.on_pulseHeartbeat_response();
  }

  /**
   * Remote viewer response to configureClient query.
   * See {@link GatewayRequestSender#configureClient}.
   */
  private _configureClient_response({ dataView }: { dataView: DataView }) {
    this._handler!.on_configureClient_response({
      codec: dataView.getUint8(0),
    });
  }

  /**
   * Remote viewer response to resize query.
   * See {@link GatewayRequestSender#resize}.
   */
  private _resize_response({ dataView }: { dataView: DataView }) {
    const size = deserialize_Vec2ui16({ dataView, offset: 0 });
    this._handler!.on_resize_response({ size });
  }

  /**
   * Remote viewer message.
   */
  private _onFrameReceived({ dataView }: { dataView: DataView }) {
    let offset = 0;

    const encoded_frame_size = dataView.getUint32(offset, LITTLE_ENDIAN);
    offset += 4;

    const meta_data_size = dataView.getUint32(offset, LITTLE_ENDIAN);
    offset += 4;

    const encoded_frame = new DataView(
      dataView.buffer,
      dataView.byteOffset + offset,
      encoded_frame_size
    );
    offset += encoded_frame_size;

    this._handler!.onFrameReceived({
      encoded_frame_size,
      meta_data_size,
      encoded_frame,
      meta_data: deserialize_FrameMetaData({ dataView, offset }),
    });
  }

  /**
   * Rendering server response.
   */
  private _clientRemoteOperation_response({
    dataView,
  }: {
    dataView: DataView;
  }) {
    const FTL_CLIENT_ROP_HEADER_SIZE = 24;
    const rop_id = dataView.getUint8(0);
    const ropDataView = new DataView(
      dataView.buffer,
      FTL_CLIENT_ROP_HEADER_SIZE
    );

    switch (rop_id) {
      case ClientRemoteOperation.cast_screen_space_ray:
        this._castScreenSpaceRay_response({ dataView: ropDataView });
        break;
    }
  }

  /**
   * Rendering server response.
   */
  private _castScreenSpaceRay_response({ dataView }: { dataView: DataView }) {
    let offset = 0;

    const entity_rtid = BigInt(dataView.getUint32(offset, LITTLE_ENDIAN));
    offset += 4;

    const position = deserialize_Vec3({ dataView, offset });
    offset += 3 * 4;

    const normal = deserialize_Vec3({ dataView, offset });
    offset += 3 * 4;

    this._handler!.on_castScreenSpaceRay_response({
      entity_rtid,
      position,
      normal,
    });
  }
}
