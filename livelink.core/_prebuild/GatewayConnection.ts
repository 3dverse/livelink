/**
 * DO NOT EDIT THIS FILE MANUALLY.
 * This file has been generated automatically from its AsyncAPI spec file.
 * See : https://gitlab.com/3dverse/platform/libs/js/asyncapi-server-generator
 */

import { FTL_HEADER_SIZE, LITTLE_ENDIAN } from "../sources/types/constants";
import { UUID_BYTE_SIZE, deserialize_UUID } from "../sources/types";
import { GatewayMessageHandler } from "./GatewayMessageHandler";
import { ChannelId } from "./messages/gateway/enums";

/**
 * Holds the connection to the cluster gateway hosting the renderer and the viewer handling the
 * session.
 *
 *                     ┌─────────┬──────────────┐
 *                     │         │              │
 *                     │         │ ┌──────────┐ │
 *                     │         │ │ Renderer │ │
 *                     │         │ └─────┬────┘ │
 *    ┌────────┐       │         │       │      │
 *    │ Client │◄──────► Gateway ◄───────┤      │
 *    └────────┘       │         │       │      │
 *                 ▲   │         │  ┌────┴───┐  │
 *                 |   │         │  │ Viewer │  │
 * GatewayConnection   │         │  └────────┘  │
 *                     │         │              │
 *                     └─────────┴──────────────┘
 *
 * Responsibilities of this class are threefold:
 *  - Open, maintain, and handle any error in the connection to the gateway.
 *
 *  - Apply the authentication protocol when the first message is received.
 *    Note that initiating the authentication doesn't fall under this class's purview.
 *
 *  - Demultiplex messages following the gateway Livelink Protocol.
 *    It is only responsible for deserializing the multiplexer binary header data according to the
 *    Livelink protocol specifications; in no case is it supposed to apply any kind of logic beyond
 *    routing messages to the appropriate handler.
 */
export class GatewayConnection {
    /**
     * Socket connected to the cluster gateway.
     */
    #socket: WebSocket | null = null;

    /**
     * Controller responsible for handling messages coming from the gateway.
     */
    #handler: GatewayMessageHandler;

    /**
     * Constructs a connection linked to the specified message handler.
     */
    constructor({ handler }: { handler: GatewayMessageHandler }) {
        this.#handler = handler;
    }

    /**
     * Opens a connection to the gateway.
     *
     * @throws {Error} Socket errors
     */
    async connect({ gateway_url }: { gateway_url: string }): Promise<void> {
        return new Promise(resolve => {
            this.#socket = new WebSocket(gateway_url);
            this.#socket.binaryType = "arraybuffer";

            this.#socket.onopen = (event: Event) => {
                this.#onSocketOpened(event);
                resolve();
            };

            this.#socket.onclose = this.#onSocketClosed;

            this.#socket.onerror = () => {
                throw new Error("Gateway socket error");
            };

            // Temporary onmessage that handles only authentication response message.
            // When the socket is opened we send a message to authenticate the client, then the
            // renderer sends us back the confirmation (or an error).
            // This callback handles only this authentication response message.
            // As soon as the authentication is validated, we switch to the regular multiplexed
            // message handler callback.
            this.#socket.onmessage = this.#onAuthenticated;
        });
    }

    /**
     *
     */
    send({ data }: { data: ArrayBufferLike | string }): void {
        this.#socket?.send(data);
    }

    /**
     *
     */
    disconnect(): void {
        this.#socket?.close(1000);
    }

    /**
     *
     */
    #onSocketOpened = (_: Event): void => {
        console.debug("Connected to the 3dverse rendering gateway:", this.#socket!.url);
    };

    /**
     *
     */
    #onSocketClosed = (closeEvent: CloseEvent): void => {
        if (closeEvent.wasClean === false) {
            console.error("Gateway socket forcibly closed", closeEvent);
        } else {
            console.debug("Disconnected from the 3dverse rendering gateway");
        }
    };

    /**
     *
     */
    #onAuthenticated = (message: MessageEvent<ArrayBuffer>): void => {
        this.#handler._on_authenticateClient_response({
            data_view: new DataView(message.data),
        });

        // Switch the onmessage callback to the regular multiplexed one.
        this.#socket!.onmessage = this.#onMessageReceived;
    };

    /**
     *
     */
    #onMessageReceived = (message: MessageEvent<ArrayBuffer>): void => {
        // First byte is the channel id.
        // 3 following bytes are the message total size EXCLUDING the first 4 bytes.
        const channelId = new DataView(message.data).getUint8(0) as ChannelId;
        const data_view = new DataView(message.data, FTL_HEADER_SIZE);

        switch (channelId) {
            case ChannelId.registration:
                this.#handler._on_configureClient_response({ data_view });
                break;

            case ChannelId.video_stream:
                this.#handler._onFrameReceived({ data_view });
                break;

            case ChannelId.viewer_control:
                this.#handler._on_resize_response({ data_view });
                break;

            case ChannelId.client_remote_operations:
                this.#clientRemoteOperation_response({ data_view });
                break;

            case ChannelId.heartbeat:
                this.#handler._on_pulseHeartbeat_response();
                break;

            case ChannelId.broadcast_script_events:
                this.#handler._onScriptEventReceived({ data_view });
                break;

            case ChannelId.audio_stream:
            case ChannelId.asset_loading_events:
            case ChannelId.gpu_memory_profiler:
                break;

            default:
                throw new Error(`Received message on an unsupported channel '${ChannelId[channelId]}' (${channelId})`);
        }
    };

    /**
     * Rendering server response.
     */
    #clientRemoteOperation_response({ data_view }: { data_view: DataView }): void {
        let offset = 0;
        const client_id = deserialize_UUID({ data_view: data_view, offset });
        offset += UUID_BYTE_SIZE;
        const request_id = data_view.getUint32(offset, LITTLE_ENDIAN);
        offset += 4;
        const size = data_view.getUint32(offset, LITTLE_ENDIAN);
        offset += 4;

        this.#handler._on_clientRemoteOperation_response({
            client_id,
            request_id,
            size,
            data_view: new DataView(data_view.buffer, data_view.byteOffset + offset),
        });
    }
}
